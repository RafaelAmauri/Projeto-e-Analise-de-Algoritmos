\subsection{Abordagem gulosa}

    Abordagem Gulosa é uma estratégia que tenta resolver o problema fazendo a 
    escolha ótima localmente em cada fase com o intuito de encontrar 
    uma ótima global que resolve o problema por completo.

    Para o uso dessa abordagem, duas propriedades são de suma importância: 

    \begin{itemize}
        \item \textbf{Greedy Choice Property}: Uma solução global otimizada pode ser obtida,
        selecionado uma solução ótima local.
        \item \textbf{Optimal Substructure}: uma solução ótima pode ser construída, 
        usando a solução ótima para os seus subproblemas.
    \end{itemize}

    Um exemplo de abordagem gulosa é o Algoritmo de Dijkstra.

    \subsubsection{Algoritmo de Dijkstra}

    \begin{figure}[ht]
        \centering
        \includegraphics[width=.7\textwidth]{dijkstra.png}
        \caption{Um caso comum em encontrar o menor caminho entre dois pontos, é encontrar 
        a menor distância entre duas cidades}
        \label{fig:dikstra}
    \end{figure}

    Dado um grafo qualquer e dois pontos: partida e chegada, encontre o menor caminho possível.
    Para resolver esse problema, Dijkstra cria o que é chamado de \emph{Shortest path tree}(spt) ou 
    a árvore de caminho mais curto. A cada passo do algoritmo, a \textbf{spt} adiciona uma vértice não visitada,
    e então atualiza a distância das adjacências da vértice que foi adicionada. O algoritmo irá terminar quando 
    a \textbf{spt} conter informação de todas as vértices.

    \begin{algorithm}
        \caption{Dijkstra} 
        \begin{algorithmic}[1]
        \Procedure{Dijkstra}{origin,destination}
        \For{$\text{each v $\in$ G.vertices}$}
        \State {$\text{distance[v] = $\infty$}$}
        \EndFor
        \State {$\text{A $\leftarrow$ G.vertices}$}
        \State {$\text{distance[origin] = 0}$}
        \For{$\text{j = 1 in $\mid G.vertices\mid$ -1}$}
        \State {$\text{u := Extract-Min(A)}$}
        \State {$\text{A.pop(u)}$}
        \For{$\text{each v $\in$ Neighbors(u)}$}
        \State {$\text{Update(distance,v)}$}
        \EndFor
        \EndFor
        \State {$\text{\textbf{return} distance[destination]}$}
        \EndProcedure
        \end{algorithmic}
    \end{algorithm}

    \subsubsection{Algoritmo Guloso Vs Backtracking}

    \begin{itemize}
        \item Por sua natureza, a estratégia Gulosa pode não alcançar imediatamente 
        o resultado global ótimo, um efeito que também está presente nos algoritmos que utilizam \emph{Backtracking}
        \item Devido a natureza da estratégia de backtracking, tais algoritmos costumam ter 
        implementações recursivas, enquanto que algoritmos gulosos tentam 
        buscar a melhor escolha local de forma iterativa.
    \end{itemize}

    \subsubsection{Algoritmo Guloso Vs Branch and Bound}

    \begin{itemize}
        \item Algoritmos gulosos costumam ter resultados mais rápidos do que técnicas de 
        \emph{Branch and Bound} para problemas com menos \emph{entrada}, mas à medida que a entrada cresce o mesmo 
        pode acabar sendo custoso como o \emph{Branch and Bound}
        \item \emph{Branch and Bound}, assim como \emph{Backtracking}, consegue voltar a estados anteriores 
        da árvore para encontrar a solução, enquanto isso, algoritmos gulosos tentam 
        buscar a melhor escolha local de forma iterativa e não dividem o problema em \emph{"checkpoints"}
    \end{itemize}

    \nocite{greedy-algorithm}

\newpage