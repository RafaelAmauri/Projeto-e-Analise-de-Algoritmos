\subsection{Divisão e conquista}

    Divisão e Conquista é uma técnica que pode ser dividida em três 
    partes fundamentais: dividir um problema maior recursivamente em 
    problemas menores(\textbf{Dividir}), resolver todos os 
    sub-problemas (\textbf{Conquistar}). Por fim, a solução do problema inicial 
    é dada através da combinação dos resultados de todos os problemas 
    menores computados(\textbf{Combine}). 

    Problemas que usam divisão e conquista são característiscos em possuir um princípio 
    chamado \textbf{Overlapping subproblems}, ou seja, o problema pode ser divido em 
    subproblemas, que são reutilizados várias vezes e que não geram novos subproblemas.
    
    Exemplos de problemas conhecidos que usam desta estratégia, é o problema de 
    ordenação interna(usando quicksort ou mergesort), ou o problema dos pares de pontos próximos.

\subsubsection{Pares de pontos próximos}

    Dado um conjunto de n pontos em um espaço, é preciso encontrar os dois pontos do conjunto que possuem a 
    menor distância um do outro. Este problema possui mais de uma possível implementação, porém 
    uma das mais eficientes é utilizando divisão e conquista.

    \begin{figure}[ht]
        \centering
        \includegraphics[width=.5\textwidth]{divide-and-conquer.png}
        \caption{Uma representação visual da separação dos pontos}
        \label{fig:divide-and-conquer}
    \end{figure}

    Supondo que a entrada para o problema é um conjunto de pontos com o eixo y já ordenado,
    encontramos o ponto do meio, separamos o conjunto ao meio, e então recursivamente descobrimos
    as menores distâncias entre os conjuntos separados, para então achar a solução geral.

    \newpage 

    \begin{algorithm}
        \caption{Closest pair of points} 
        \begin{algorithmic}[1]
        \Procedure{Divide-and-conquer}{}
        \State {$d_{min}$ $\gets$ $min(d_L,d_R)$}
        \State {$Y_{L}$ $\gets$ $\text{ set of y-sorted points in }$ $\Delta$ $\text{ lying to the left of \textbf{l}}$}
        \State {$Y_{R}$ $\gets$ $\text{ set of y-sorted points in }$ $\Delta$ $\text{ lying to the right of \textbf{l}}$}
        \State {$text{left}$ $\gets$ $first[Y_L]$}
        \State {$text{right}$ $\gets$ $first[Y_R]$}
        \If{$\text{colors[v] == WHITE}$}
        \State {$\textbf{visit(v,colors)}$}
        \EndIf
        \EndProcedure
        \end{algorithmic}
      \end{algorithm}

      \subsubsection{Divisão e Conquista Vs Backtracking}

      \begin{itemize}
          \item Devido a maneira como ambos são conceptualizados, ambos possuem a 
          natureza de serem recursivos.
          \item Em divisão e conquista, precisamos analisar a entrada inteira do usuário 
          para resolver o problema, enquanto que backtracking pode ou não analisar a todas 
          as possibilidades dentro da entrada do usuário
      \end{itemize}

      \subsubsection{Divisão e Conquista Vs Branch and Bound}

      \begin{itemize}
          \item Enquanto divisão e conquista divide a entrada do usuário(Ex: divide o vetor de 
          números para ordená-los), para resolver os sub-problemas e então resolver a combinação
          desses problemas. A outra estratégia, divide o espaço da solução para o problema.
          \item Tanto Branch and Bound e Divide and Conquer são estratégias que partem dos 
          mesmos princípios, ambas querem dividir o problema em partes menores, para resolver 
          o problema todo.
      \end{itemize}

    \nocite{divide-and-conquer}
    \nocite{closest-pair-of-points}
\newpage